\subsection{État du jeu}
Nous essaierons de simplifier au plus le jeu ``Candy Crush'' par l'utilisation de structures.\smallskip

Ce jeu comme beaucoup d'autres est jouable en niveaux qui sont caractérisés par certaines variables que nous présenterons ici : \\


\begin{typeag}[Niveau]
 -       \variable{numeroNiveau}{entier}{Les niveaux sont représentés par leur numéro (présent au départ)}\\
 -       \variable{deplacementMax}{entier}{Le nombre de déplacements maximum possibles selon le niveau}\\
 -       \variable{deplacementsUtilises}{entier}{Le nombre de déplacements effectués par l'utilisateur pendant la partie}\\
 -       \variable{grille}{[tailleGrilleX][tailleGrilleY]}{représente la grille d'entiers avec une taille en X et Y \\0 = case non jouable \\ 1,2,3,4,5 = couleur de bonbons }\\
 -       \variable{grilleDeDestruction}{booleen [tailleGrilleX][tailleGrilleY]}{est une seconde grille de booleens qui stocke les cases à détruire }
  \end{typeag}		\\
  
  On crée un type agrégé représentant la position en x et y afin de cibler les cases plus tard : \\
  
  \begin{typeag}[Position]
 -       \variable{x}{entier}{position en x}\\
 -       \variable{y}{entier}{position en y}
  \end{typeag}	\\
  
  Le joueur va interagir avec le jeu en déplaçant les cases afin de créer des combinaision de couleurs.
  Ainsi, on crée une structure qui cible la case initiale et la case cible par leur position : \\
  
  \begin{typeag}[Joueur]
 -       \variable{caseADeplacer}{Position}{représente la position en x et y de la case que l'on souhaite déplacer}\\
 -       \variable{caseCible}{Position}{représente la position en x et y de la case que l'on cible}
  \end{typeag}	\\
  
  La récompense du jeu se traduit par un score à obtenir afin de passe un niveau par exemple.
  Il nous faut donc une structure qui stocke le score que l'on doit obtenir pour gagner et aussi qui stocke le score actuel du joueur : \\
  
  \begin{typeag}[Score]
 -       \variable{scoreCible}{entier}{score à atteindre (présent au départ)}\\
 -       \variable{scoreActuel}{entier}{stockage du score après chaque coup du joueur}
  \end{typeag}	\\
  
  Cette structure va permettre de définir les conditions de validité d'une combinaison et si un déplacement est possible : \\
  
\begin{typeag}[Case]
 -       \variable{caseTemporaire}{entier}{variable qui va stocker une case temporaire pour pouvoir inverser deux cases}\\
 -       \variable{nbCasesAlignes}{entier}{variable qui va compter le nombre de cases alignées}
  \end{typeag}

\subsection{Configuration initiale du jeu}
Nous allons maintenant analyser la situation de départ du jeu. Dès le départ, le joueur dispose d'un certain nombre d'éléments : \\

\begin{itemize}

\item
	Tout d'abord, le décor est constitué d'une grille modulable selon le niveau, c'est à dire avec une surface différente.
	Par exemple, on peut avoir une niveau assez simple (souvent au début) qui a une seule grille rectangulaire ou dans des niveaux plus complexes, plusieurs grilles avec des formes différentes.
\item
	Les bonbons qui constituent le jeu ont des couleurs qui va permettent de faire des combinaisons.
	Couleurs : jaune, rouge, vert, bleu et orange.
\item
	À l'écran sera affiché le nombre de coups limite afin de réussir le niveau % On a enlevé le temps, je crois
\item
	Le joueur dispose aussi d'une jauge de points qui augmente au fur et à mesure des combinaisons.
	Évidemment, le score est 0 au départ.
\item
	Le joueur a aussi directement accès à son objectif à réaliser pour passer le niveau et son avancement dans celui-ci.
\item 
 	Pour que le jeu soit viable, il faut qu'il n'y ait pas de combinaisons directes au départ (\emph{ex.: 3 bonbons alignés dès le début}). % mais aussi qu'il y ait au moins une solution possible si on déplace un bonbon d'une case. --> Un peu difficile pour l'analyse...
	
\end{itemize}

\subsection{Évolution de l'état du jeu}

Le jeu consiste à déplacer deux éléments pour créer des alignements d'au moins 3 cases identiques. Pour ce faire, on va procéder en plusieurs étapes :

\subsubsection{Vérification du déplacement}
Avant de pouvoir échanger deux cases, il faut vérifier plusieurs choses :
\begin{itemize}
	\item
		Le déplacement ne sort pas de la grille
\begin{lstlisting}
caseDestination.x >= 0 && caseDestination.x < tailleGrilleX && caseDestination.y >= 0 && caseDestination.y < tailleGrilleY
\end{lstlisting}
	\item
		Le déplacement ne va pas sur une case non-jouable
\begin{lstlisting}
grille[caseDestination.x][caseDestination.y] != 0 && grille[caseADeplacer.x][caseADeplacer.y] != 0
\end{lstlisting}
	\item
		Les cases sont côtes à côtes (si on clique autre part, ça change la position de la caseADeplacer) :
\begin{lstlisting}
caseADeplacer.x - caseDestination.x == 1 || caseADeplacer.x - caseDestination.x == -1 || ( caseADeplacer.x - caseDestination.x != 1 && caseADeplacer.x - caseDestination.x != -1 && (caseADeplacer.y - caseDestination.y == 1 || caseADeplacer.y - caseDestination.y == -1) )
\end{lstlisting}
	\item
		Le déplacement va créer un alignement de au moins 3 cases identiques : pour cela, on va tout d'abord échanger les deux cases sélectionnées grace à la case temporaire :
\begin{lstlisting}
caseTemporaire = grille[caseDestination.x][caseDestination.y];
grille[caseDestination.x][caseDestination.y] = grille[caseADeplacer.x][caseADeplacer.y];
grille[caseADeplacer.x][caseADeplacer.y] = caseTemporaire;
\end{lstlisting}
		On peut alors commencer la détection des cases à détruire. Si il n'y a aucune case à détruire (lors de la première fois qu'on cherche), il n'y a donc pas de combinaison, on peut alors rééchanger les cases.
\end{itemize}

\begin{figure}[position]
	\center
	\caption{\label{verifDepl} Déplacements}
	\includegraphics{imgs/verifDepl}
\end{figure}
		
\subsubsection{Détection}	
	
Pour pouvoir détecter toutes les cases à détruire, nous utilisons une autre grille de la même taille que celle contenant les éléments, mais cette nouvelle grille contient des booléens. Chaque case est ainsi associée à un booléen. Si la case doit être détruite, le booléens vaudra vrai.

On va ensuite parcourir la première grille ligne par ligne pour marquer tous les alignements horizontaux puis colonne par colonne pour les combinaisons verticales.

\begin{figure}[position]
	\center
	\caption{\label{Detection} Détection}
	\includegraphics{imgs/Detection}
\end{figure}

Nous avons besoin de quelques nouvelles variables :

\begin{lstlisting}
int couleurTemp; // Couleur temporaire qui va servir pour verifier que plusieurs cases sont identiques
int nbCasesAlignees; // Sert a compter le nombre de cases alignees
\end{lstlisting}

Pour parcourir la grille :

\begin{lstlisting}
for(int j = 0; j < tailleGrilleY; j++)
{
	couleurTemp = grille[0][j]; // La couleur temporaire est egale a la premiere case de la grille
	nbCasesAlignees = 1; // Le nombre de cases alignees est egal a 1 en debut de ligne
	/** Parcours des lignes **/
	for(int i = 0; i < tailleGrilleX; i++)
	{
		if(couleurTemp == grille[i][j]) // Si la couleur temporaire est la meme dans cette case, on incremente nbCasesAlignees
			nbCasesAlignees++;
		else if(nbCasesAlignees >= 3)
		{
			// Si la couleur n'est pas la meme mais qu'on a un alignement, on note dans le deuxieme tableau
			nbCasesAlignees = 1;
			couleurTemp = grille[i][j];
			pasDeCasesADetruire = false;
		}
		else
		{
			nbCasesAlignees = 1;
			couleurTemp = grille[i][j];
		}

		if(i == tailleGrilleX - 1 && nbCasesAlignees >= 3) 
			/* Si on atteind le bord de la grille et qu'on a un alignement de plus de 3,
			on note dans le tableau apres avoir incremente i, pour utiliser la meme fonction de notation dans l'autre tableau. */
	}
} 
\end{lstlisting}
		Pour noter les cases à détruire dans la seconde grille, on peut simplement faire :
\begin{lstlisting}
for(int k = i - nbCasesAlignees; k < i; k++) // On parcours les cases a noter, mais on ne passe pas quand k == i car la case i ne fait pas partie de l'alignement
{
	grilleDeDestruction[k][j] = true;
}
\end{lstlisting}

Il faudra refaire ce processus de détection des alignements verticalement, donc colonne par colonne. Le principe est identique.

\subsubsection{Destruction}

Pour détruire les cases, nous remplaçons les cases à détruire par -1 dans la grille.

\begin{figure}[position]
	\center
	\caption{\label{Destruction} Destruction}
	\includegraphics{imgs/Destruction}
\end{figure}

Cela se traduit comme suit :

\begin{lstlisting}
for(int j = 0; j < tailleGrilleY; j++)
{
	for(int i = 0; i < tailleGrilleX; i++)
	{
		if(grilleDeDestruction[i][j] == true)
		{
			grille[i][j] = -1;
			grilleDeDestruction[i][j] = false; // On en profite pour reinitialiser la deuxieme grille qui sert pour la destruction
		}
	}
}
\end{lstlisting}

\subsubsection{Remplacement}

	Afin de remplacer les cases détruites (donc -1 dans la grille), il faut trier la grille de manière à avoir tout les -1 au dessus.
	Il faut tout de même penser aux cases inutilisables (0 dans la grille) qui ne doivent pas être bougées.
	
	Nous allons donc parcourir chaque colonne en partant du bas, et lorsqu'on trouve un -1, nous allons le remplacer par la prochaine case valide (qu'on mettra à -1).
	
\begin{figure}[position]
	\center
	\caption{\label{Remplacement} Remplacement}
	\includegraphics{imgs/Remplacement1}
	\includegraphics{imgs/Remplacement2}
\end{figure}
	
	Pour une colonne k, nous aurons :
\begin{lstlisting}
int j;
boolean continuer;
for(int i = tailleGrilleY - 1; i >= 0; i--)
{
	if(grille[k][j] == -1)
	{
		j = i;
		continuer = true;
		while(j >= 0 && continuer == true)
		{
			j--;
			if(grille[k][j] != 0 && grille[k][j] != -1) // Si on trouve une case correcte, on remplace
			{
				grille[k][i] = grille[k][j];
				grille[k][j] = -1;
				continuer = false; // On n'a plus besoin de rechercher
			}
		}
	}
}
\end{lstlisting}

	Il faudra faire une boucle pour répliquer ce résonnement à chaque colonne. Notons qu'on pourrais ajouter une condition qui arrêterais la boucle la première fois que le while ne trouve pas de case valide.
	
	Désormais, il ne reste plus qu'à remplacer toutes les cases -1 par un numéro aléatoire 1, 2, 3, 4 ou 5 représentant les différents types de cases.

\begin{lstlisting}
for(int j = 0; j < tailleGrilleY; j++)
{
	for(int i = 0; i < tailleGrilleX; i++)
	{
		if(grille[i][j] == -1;
			grille[i][j] = (int)(Math.random() * 5) + 1;
	}
}
\end{lstlisting}

\subsubsection{Finalement}

Ce processus Détection-Destruction-Remplacement devra être répété jusqu'à ce qu'il n'y ait plus aucune case à détruire.

De plus, un score à atteindre pourra être fixé. Pour cela, chaque destruction de case (quand on les mets à -1) incrémentera d'un certain nombre de points la variable scoreActuel. Le jeu pourra s'arrêter lorsque le score ciblé est atteint.
\begin{lstlisting}
scoreActuel >= scoreCible
\end{lstlisting}

Il est également possible de compter le nombre de coups que le joueur a utilisé. En effet, il suffit de le faire lors de l'échangement des cases. Si cet échange est par la suite annulé, le nombre de coups sera remis à son état d'avant l'échange.
Avec ceci, on peut définir un certain nombre de vies que le joueur possède, et qu'il perd à la perte d'un niveau, quand il n'a plus de vie, il doit attendre pour pouvoir continuer à jouer.
Enfin, lors du premier remplissage de la grille (un nombre aléatoire dans chaque case), il faudra éliminer toutes le combinaisons, c'est à dire lancer le processus Détection-Destruction-Remplacement autant de fois qu'il le faudra.

\subsection{Annexe}
Dans cette partie, nous ajouterons les analyses que nous avons pu faire sur \emph{Candy Crush} mais qui sont difficilement réalisables.
On peut compter parmi celles-ci les bonus qui s'obtiennent par certaines combinaisons de bonbons.
\begin{itemize}

\item
	Combinaison de 4 bonbons = un bonbon spécial qui détruit une ligne ou une colonne entière (selon le sens de ses rayures)

\item
	Combinaison de 5 bonbons = bombe multicolore (l'associer avec un autre bonbon détruit tout les bonbons du type associé présents dans la grille)
\item
	Bonbons spéciaux qui détruisent tout les bonbons autour d'eux : quand on fait deux combinaisons de 3 (en L)
\item
	Bonbons à retardement : vont exploser et détruire les bonbons autour d'eux 
\item
	Association de deux bonbons spéciaux pour un plus gros (détruit 3 lignes et 3 colonnes)      
\item
	Combos : une combinaison en entraîne d'autres (ajout de points)
\item
	Une combinaison détruit les bonbons et d'autres les remplacent (tombent du dessus) 
\item
	Destruction automatique des bonbons spéciaux à la fin du niveau

\end{itemize}
